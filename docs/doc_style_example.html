<DOCTYPE html>
<head>
<link rel='stylesheet' href='docstyle.css'/></head>
<body>

<H1>AllegroFlare Documentation</H1>
<h3></h3>
<pre class='code'>
// captures comments and definitions (but definitions have a leading newline: \n(?P&lt;name&gt;(\n\/\/ (.+))+)(?P&lt;function_def&gt;(\n.+)+)</pre>
<p>
parsing this file for documentation is like this
here is the regular expression for a section header: \n//\n.+\n(//.*\n)*//\n\n
captures the comments: \n(?P<comment>(\n\/\/ (.+))+)</p>
<h3></h3>
<pre class='code'>
#define ALLEGRO_FLAGS_EMPTY 0</pre>
<p>
macro that replaces previous usage of NULL.</p>
<h3></h3>
<pre class='code'>
static const float FULL_ROTATION = 6.28318531;</pre>
<p>
</p>
<p class='todo'>TODO: change to #define.</p><h3></h3>
<pre class='code'>
static const float TAU = 6.28318531;</pre>
<p>
</p>
<p class='todo'>TODO: change to #define.</p><h3>degrees_to_radians</h3>
<pre class='code'>
float degrees_to_radians(float deg);</pre>
<p>
Converts a value from degrees to radians.</p>
<h3>radians_to_degrees</h3>
<pre class='code'>
float radians_to_degrees(float rad);</pre>
<p>
Converts a value from radians to degrees.</p>
<h3>basically_equal</h3>
<pre class='code'>
bool basically_equal(float v1, float v2, float threshold=0.00001f);</pre>
<p>
Returns true if the value of two floats are equivalent within a given threshold.
Sometimes using the == operator between two floats might produce unexpected results
doe to precision and rounding errors.  Using this function will help reduce that
potential pitfall.</p>
<h3>limit</h3>
<pre class='code'>
template&lt;class T&gt;
T limit(const T &amp;range1, const T &amp;range2, const T &amp;val)
{
	float min = (range1 &lt; range2) ? range1 : range2;
	float max = (range1 &gt; range2) ? range1 : range2;
	if (val &lt; min) return min;
	if (val &gt; max) return max;
	return val;
}</pre>
<p>
Returns a number whose value has been limited to be within (non-inclusive) a range.</p>
<h3>in_range</h3>
<pre class='code'>
template&lt;class T&gt;
bool in_range(const T &amp;min, const T &amp;max, const T &amp;val)
{
	if (val &lt; min) return false;
	if (val &gt; max) return false;
	return true;
}</pre>
<p>
Finds if a value is within (non-inclusive) the given min and max ranges.</p>
<h3>mid</h3>
<pre class='code'>
template&lt;class T&gt;
T mid(const T &amp;val1, const T &amp;val2)
{
	return (max(val1, val2) - min(val1, val2)) / 2.0 + min(val1, val2);
}</pre>
<p>
Returns the midpoint between two values.</p>
<h3>round</h3>
<pre class='code'>
float round(float val);</pre>
<p>
Returns the next greatest whole number if the given value is not a whole number itself; e.g. it rounds the number up.</p>
<h3>is_number</h3>
<pre class='code'>
bool is_number(const std::string&amp; s); </pre>
<p>
Returns true if the given string only contains characters that pass <code>std::is_digit()</code>.
</p>
<p class='todo'>TODO: rename this to to_int or something similar</p><h3>binary_find</h3>
<pre class='code'>
template&lt;class Iter, class T&gt;
inline Iter binary_find(Iter begin, Iter end, T val)
{
    // Finds the lower bound in at most log(last - first) + 1 comparisons
    Iter i = std::lower_bound(begin, end, val);</pre>
<p>
Finds an element matching <code>val</code> using a binary search (your elements must already be ordered).
</p>
<p class='todo'>TODO: this function is unfinished</p><h3>tostring</h3>
<pre class='code'>
template&lt;class T&gt;
std::string tostring(T val)
{
	std::ostringstream s;
	s &lt;&lt; val;
	return s.str();
}</pre>
<p>
Converts a value to a string representation.</p>
<h3>get_xml_encoded_ustr</h3>
<pre class='code'>
std::string get_xml_encoded_ustr(ALLEGRO_USTR *ustr);</pre>
<p>
Returns a string with each character encoded in XML, e.g. #&x00fe;.</p>
<h3>escape_xml_chars</h3>
<pre class='code'>
std::string escape_xml_chars(std::string xml);</pre>
<p>
Escapes any XML characters in a string.  
This is useful for passing complex arguments in a CURL command.</p>
<h3>as_hex</h3>
<pre class='code'>
std::string as_hex(int32_t num);</pre>
<p>
Converts an int32_t into the string hexidecimal representation of the number.
</p>
<p class='todo'>TODO should change this function name to to_hex_string() or something similar.</p><h3>to_int</h3>
<pre class='code'>
std::vector&lt;int&gt; to_int(const std::vector&lt;std::string&gt; &amp;arr);</pre>
<p>
Returns an array of ints given an array of strings..</p>
<h3>get_datetime_str</h3>
<pre class='code'>
std::string get_datetime_str();</pre>
<p>
Returns the current datetime in "DD-MM-YYYY HH:MM:SS" format.
</p>
<p class='todo'>TODO: test in gcc</p><h3>random_bool</h3>
<pre class='code'>
bool random_bool();</pre>
<p>
Returns a random boolean <code>true</code> or <code>false</code>.</p>
<h3>random_float</h3>
<pre class='code'>
float random_float(float min, float max);</pre>
<p>
Returns a random float between <code>min</code> and <code>max</code> (inclusive).</p>
<h3>random_double</h3>
<pre class='code'>
double random_double(double min, double max);</pre>
<p>
Returns a random double between min and max (inclusive).</p>
<h3>random_int</h3>
<pre class='code'>
int random_int(int min, int max);</pre>
<p>
Returns a random integer between min and max (inclusive).</p>
<h3>random_sign</h3>
<pre class='code'>
int random_sign();</pre>
<p>
Returns either a 1 or -1, selected at random.</p>
<h3>random_letter</h3>
<pre class='code'>
unsigned char random_letter(bool lower);</pre>
<p>
Returns a random uppercase char 'A-Z'.
If <code>lower=true</code>, then a random lowercase letter 'a-z' will be returned.</p>
<h3>random_letter_or_number</h3>
<pre class='code'>
unsigned char random_letter_or_number();</pre>
<p>
Returns a char that is either an uppercase character 'A-Z', a lowercase character 'a-z', or a number character from '0-9'.</p>
<h3>random_string</h3>
<pre class='code'>
std::string random_string(unsigned int length);</pre>
<p>
Generates a string of the size length consisting of randomly selected characters [A-Za-z0-0].
This is useful for generating random strings for identifiers or unique instances.
</p>
<p class='todo'>TODO: aaaagggghhh ;[ this is not funny tested</p><h3>random_element</h3>
<pre class='code'>
template&lt;class T&gt;
T random_element(std::vector&lt;T&gt; &amp;elements)
{
	return elements[random_int(0, elements.size())];
}</pre>
<p>
Returns a randomly selected element from the vector.
WARNING: this function does not do any bounds checking.  If the array is empty
this function will throw an out-of-bounds exception.</p>
<h3>random_element</h3>
<pre class='code'>
template&lt;class T&gt;
T random_element(T elements[], int size)
{
	return elements[random_int(0, size-1)];
}</pre>
<p>
Returns a random selected element from an array of elements.
If the array is empty, it will throw an out-of-bounds exception.</p>
<h3>random_color</h3>
<pre class='code'>
ALLEGRO_COLOR random_color();</pre>
<p>
Returns an ALLEGRO_COLOR with randomly picked RGB values.
</p>
<p class='todo'>TODO: This function is more useful for tests. Since the RGB values are generated
independently, the colors that are typically generated fall into the middle of the
color space.  A better, more 'random' color might integrate some color theory. </p><h3>dot_product</h3>
<pre class='code'>
float dot_product(vec3d A, vec3d B);</pre>
<p>
Calculate the dot product between two vectors.</p>
<h3>cross_product</h3>
<pre class='code'>
vec3d cross_product(vec3d A, vec3d B);</pre>
<p>
Calculate the cross product between two vectors.</p>
<h3>project</h3>
<pre class='code'>
vec2d project(vec2d &amp;point, vec2d &amp;axis);
vec3d project(vec3d point, vec3d point_on_plane, vec3d normal_of_plane);</pre>
<p>
Returns a point projected onto an axis.</p>
<h3>rotate_point</h3>
<pre class='code'>
vec2d rotate_point(vec2d point, float angle);</pre>
<p>
Rotates a point by an angle.</p>
<h3>reflect</h3>
<pre class='code'>
vec2d reflect(vec2d &amp;point, const vec2d &amp;axis);
vec3d reflect(vec3d &amp;point, const vec3d &amp;axis);</pre>
<p>
Reflects a point along an axis.</p>
<h3>distance</h3>
<pre class='code'>
float distance(float x1, float y1, float x2, float y2);
float distance(const vec2d &amp;point1, const vec2d &amp;point2);
float distance(const vec2d *point1, const vec2d *point2);</pre>
<p>
Calculates the distance between points.</p>
<h3>manhattan_distance</h3>
<pre class='code'>
float manhattan_distance(float x1, float y1, float x2, float y2);
float manhattan_distance(const vec2d *point1, const vec2d *point2);</pre>
<p>
Calculates the manhattan distance between points (google "Manhattan Distance").
Manhattan distance is a slightly faster (but less accurate) alternative to the distance formula.</p>
<h3>distance_squared</h3>
<pre class='code'>
float distance_squared(const vec2d &amp;point1, const vec2d &amp;point2);</pre>
<p>
Calculates the distance squared between points.
Finding the distance squared is a fast calculation, so you might use it to prune out
possible collisions between objects before calculating a more accurate distance
with the usual <code>distance()</code> function.</p>
<h3>draw_crosshair</h3>
<pre class='code'>
void draw_crosshair(float x, float y, ALLEGRO_COLOR color=al_color_name(&quot;white&quot;));
void draw_crosshair(float x, float y, float z, ALLEGRO_COLOR col=color::black, float size=10);
void draw_crosshair(vec2d &amp;point, ALLEGRO_COLOR color=al_color_name(&quot;white&quot;));
void draw_crosshair(vec3d point, ALLEGRO_COLOR col=color::black, float size=10);</pre>
<p>
Draws a crosshair at a given coordinate on the screen.</p>
<h3>build_vertex</h3>
<pre class='code'>
ALLEGRO_VERTEX build_vertex(float x, float y, float z, ALLEGRO_COLOR col, float u, float v);</pre>
<p>
Creates an ALLEGRO_VERTEX with the following parameters.</p>
<h3>draw_textured_rectangle</h3>
<pre class='code'>
void draw_textured_rectangle(float x, float y, float w, float h, ALLEGRO_BITMAP *texture, const ALLEGRO_COLOR &amp;color=color::white);</pre>
<p>
Draws a rectangle with the given texture.
The texture will tile if the rectangle extends beyond the width or height of the image.
The top left corner of the texture is aligned at <code>x</code> and <code>y</code> of the rectangle.  To define
an offset, use <code>draw_offset_textured_rectangle</code>.</p>
<h3>draw_offset_textured_rectangle</h3>
<pre class='code'>
void draw_offset_textured_rectangle(float x, float y, float w, float h, float offset_x, float offset_y, ALLEGRO_BITMAP *texture, const ALLEGRO_COLOR &amp;color=color::white);</pre>
<p>
Same as <code>draw_textured_rectangle</code>, but allows you to define an x and y offset for the texture.</p>
<h3>draw_stretched_bitmap</h3>
<pre class='code'>
void draw_stretched_bitmap(float x, float y, float w, float h, ALLEGRO_BITMAP *bitmap, int flip_flags=ALLEGRO_FLAGS_EMPTY, ALLEGRO_COLOR color=color::white);</pre>
<p>
Draws an image stretched to fit the given width and height.</p>
<h3>draw_unicode_char</h3>
<pre class='code'>
void draw_unicode_char(ALLEGRO_FONT *font, ALLEGRO_COLOR color, int32_t icon, int flags, float x, float y);</pre>
<p>
Draws a unicode character on the screen.
</p>
<p class='todo'>TODO: might be obsolete?  look in the unique font drawing routines.</p><h3>animate_color</h3>
<pre class='code'>
#include &lt;allegro_flare/motion.h&gt;
void animate_color(Motion *motion, ALLEGRO_COLOR *dest_color, const ALLEGRO_COLOR start, const ALLEGRO_COLOR end, double start_time, double duration, interpolator::interpolator_func_t interpolator_func);</pre>
<p>
Initializes an animation on an <code>ALLEGRO_COLOR</code> so that it will crossfade between two colors.</p>
<h3>take_screenshot</h3>
<pre class='code'>
std::string take_screenshot(std::string filename=&quot;&quot;);</pre>
<p>
Captures a screenshot of the current display (e.g. the contents of the current program window) and writes the image to a file.
If the filename is left blank, then "screenshot-[time].png" will be generated
as the filename, where [time] is in the <code>YYYY-MM-DD HH-MM-SS</code> format.
This function uses the allegro library.</p>
<h3>key_pressed</h3>
<pre class='code'>
bool key_pressed(int al_keycode);</pre>
<p>
Checks to see if a key is currently pressed.</p>
<h3>pick_filename</h3>
<pre class='code'>
std::string pick_filename();</pre>
<p>
Opens a native dialogue box prompting the user to select a file.
This is a _blocking_ function and will halt any activity that is running in the
calling thread.  This function uses the allegro path addon.
</p>
<p class='todo'>TODO: add an additional parameter limiting the file extensions.</p><h3>get_directory_listing</h3>
<pre class='code'>
#include &lt;iostream&gt;
std::vector&lt;std::string&gt; get_directory_listing(std::string directory);</pre>
<p>
Get a listing of all the files in the directory.</p>


</body>
